// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package master

import (
	"context"
)

const embeddingsCreate = `-- name: EmbeddingsCreate :one


INSERT INTO
    embeddings (embedding)
VALUES
    (?) RETURNING id
`

// Code generated by sqlcquash. DO NOT EDIT.
// versions:
//
//		sqlcquash: v0.0.2
//
//
//
//	 INSERT INTO
//	     embeddings (embedding)
//	 VALUES
//	     (?) RETURNING id
func (q *Queries) EmbeddingsCreate(ctx context.Context, embedding string) (int64, error) {
	row := q.db.QueryRowContext(ctx, embeddingsCreate, embedding)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const embeddingsGetByID = `-- name: EmbeddingsGetByID :one
SELECT
    id,
    embedding
FROM
    embeddings
WHERE
    id = ?
LIMIT
    1
`

type EmbeddingsGetByIDRow struct {
	ID        int64  `db:"id" json:"id"`
	Embedding string `db:"embedding" json:"embedding"`
}

// EmbeddingsGetByID
//
//	SELECT
//	    id,
//	    embedding
//	FROM
//	    embeddings
//	WHERE
//	    id = ?
//	LIMIT
//	    1
func (q *Queries) EmbeddingsGetByID(ctx context.Context, id int64) (EmbeddingsGetByIDRow, error) {
	row := q.db.QueryRowContext(ctx, embeddingsGetByID, id)
	var i EmbeddingsGetByIDRow
	err := row.Scan(&i.ID, &i.Embedding)
	return i, err
}

const emeddingUpdate = `-- name: EmeddingUpdate :exec
UPDATE
    embeddings
SET
    embedding = ?
WHERE
    id = ?
`

// EmeddingUpdate
//
//	UPDATE
//	    embeddings
//	SET
//	    embedding = ?
//	WHERE
//	    id = ?
func (q *Queries) EmeddingUpdate(ctx context.Context, embedding string, iD int64) error {
	_, err := q.db.ExecContext(ctx, emeddingUpdate, embedding, iD)
	return err
}

const postCreate = `-- name: PostCreate :one
INSERT INTO
    posts (
        title,
        description,
        slug,
        content,
        raw_content,
        banner_url,
        embedding_id
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?) RETURNING id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
`

type PostCreateParams struct {
	Title       string `db:"title" json:"title"`
	Description string `db:"description" json:"description"`
	Slug        string `db:"slug" json:"slug"`
	Content     string `db:"content" json:"content"`
	RawContent  string `db:"raw_content" json:"raw_content"`
	BannerUrl   string `db:"banner_url" json:"banner_url"`
	EmbeddingID int64  `db:"embedding_id" json:"embedding_id"`
}

// PostCreate
//
//	INSERT INTO
//	    posts (
//	        title,
//	        description,
//	        slug,
//	        content,
//	        raw_content,
//	        banner_url,
//	        embedding_id
//	    )
//	VALUES
//	    (?, ?, ?, ?, ?, ?, ?) RETURNING id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
func (q *Queries) PostCreate(ctx context.Context, arg PostCreateParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, postCreate,
		arg.Title,
		arg.Description,
		arg.Slug,
		arg.Content,
		arg.RawContent,
		arg.BannerUrl,
		arg.EmbeddingID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Content,
		&i.RawContent,
		&i.BannerUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmbeddingID,
	)
	return i, err
}

const postGet = `-- name: PostGet :one
SELECT
    id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
FROM
    posts
WHERE
    id = ?
LIMIT
    1
`

// PostGet
//
//	SELECT
//	    id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
//	FROM
//	    posts
//	WHERE
//	    id = ?
//	LIMIT
//	    1
func (q *Queries) PostGet(ctx context.Context, id int64) (Post, error) {
	row := q.db.QueryRowContext(ctx, postGet, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Content,
		&i.RawContent,
		&i.BannerUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmbeddingID,
	)
	return i, err
}

const postGetBySlug = `-- name: PostGetBySlug :one
SELECT
    id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
FROM
    posts
WHERE
    slug = ?
LIMIT
    1
`

// PostGetBySlug
//
//	SELECT
//	    id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
//	FROM
//	    posts
//	WHERE
//	    slug = ?
//	LIMIT
//	    1
func (q *Queries) PostGetBySlug(ctx context.Context, slug string) (Post, error) {
	row := q.db.QueryRowContext(ctx, postGetBySlug, slug)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Content,
		&i.RawContent,
		&i.BannerUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmbeddingID,
	)
	return i, err
}

const postProjectCreate = `-- name: PostProjectCreate :exec
INSERT INTO
    post_projects (post_id, project_id)
VALUES
    (?, ?)
`

// PostProjectCreate
//
//	INSERT INTO
//	    post_projects (post_id, project_id)
//	VALUES
//	    (?, ?)
func (q *Queries) PostProjectCreate(ctx context.Context, postID int64, projectID int64) error {
	_, err := q.db.ExecContext(ctx, postProjectCreate, postID, projectID)
	return err
}

const postProjectDelete = `-- name: PostProjectDelete :exec
DELETE FROM
    post_projects
WHERE
    post_id = ?
    AND project_id = ?
`

// PostProjectDelete
//
//	DELETE FROM
//	    post_projects
//	WHERE
//	    post_id = ?
//	    AND project_id = ?
func (q *Queries) PostProjectDelete(ctx context.Context, postID int64, projectID int64) error {
	_, err := q.db.ExecContext(ctx, postProjectDelete, postID, projectID)
	return err
}

const postProjectListByPost = `-- name: PostProjectListByPost :many
SELECT
    p.id, p.title, p.slug, p.description, p.content, p.raw_content, p.banner_url, p.created_at, p.updated_at, p.embedding_id
FROM
    post_projects pp
    JOIN projects p ON pp.project_id = p.id
WHERE
    pp.post_id = ?
ORDER BY
    p.name ASC
`

// PostProjectListByPost
//
//	SELECT
//	    p.id, p.title, p.slug, p.description, p.content, p.raw_content, p.banner_url, p.created_at, p.updated_at, p.embedding_id
//	FROM
//	    post_projects pp
//	    JOIN projects p ON pp.project_id = p.id
//	WHERE
//	    pp.post_id = ?
//	ORDER BY
//	    p.name ASC
func (q *Queries) PostProjectListByPost(ctx context.Context, postID int64) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, postProjectListByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Content,
			&i.RawContent,
			&i.BannerUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmbeddingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postProjectsGetByPostID = `-- name: PostProjectsGetByPostID :many
SELECT
    post_id, project_id
FROM
    post_projects
WHERE
    post_id = ?
`

// PostProjectsGetByPostID
//
//	SELECT
//	    post_id, project_id
//	FROM
//	    post_projects
//	WHERE
//	    post_id = ?
func (q *Queries) PostProjectsGetByPostID(ctx context.Context, postID int64) ([]PostProject, error) {
	rows, err := q.db.QueryContext(ctx, postProjectsGetByPostID, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostProject
	for rows.Next() {
		var i PostProject
		if err := rows.Scan(&i.PostID, &i.ProjectID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postProjectsGetByProjectID = `-- name: PostProjectsGetByProjectID :many
SELECT
    post_id, project_id
FROM
    post_projects
WHERE
    project_id = ?
`

// PostProjectsGetByProjectID
//
//	SELECT
//	    post_id, project_id
//	FROM
//	    post_projects
//	WHERE
//	    project_id = ?
func (q *Queries) PostProjectsGetByProjectID(ctx context.Context, projectID int64) ([]PostProject, error) {
	rows, err := q.db.QueryContext(ctx, postProjectsGetByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostProject
	for rows.Next() {
		var i PostProject
		if err := rows.Scan(&i.PostID, &i.ProjectID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postTagCreate = `-- name: PostTagCreate :exec
INSERT INTO
    post_tags (post_id, tag_id)
VALUES
    (?, ?)
`

// PostTagCreate
//
//	INSERT INTO
//	    post_tags (post_id, tag_id)
//	VALUES
//	    (?, ?)
func (q *Queries) PostTagCreate(ctx context.Context, postID int64, tagID int64) error {
	_, err := q.db.ExecContext(ctx, postTagCreate, postID, tagID)
	return err
}

const postTagDelete = `-- name: PostTagDelete :exec
DELETE FROM
    post_tags
WHERE
    post_id = ?
    AND tag_id = ?
`

// PostTagDelete
//
//	DELETE FROM
//	    post_tags
//	WHERE
//	    post_id = ?
//	    AND tag_id = ?
func (q *Queries) PostTagDelete(ctx context.Context, postID int64, tagID int64) error {
	_, err := q.db.ExecContext(ctx, postTagDelete, postID, tagID)
	return err
}

const postTagGet = `-- name: PostTagGet :one
SELECT
    post_id, tag_id
FROM
    post_tags
WHERE
    post_id = ?
    AND tag_id = ?
`

// PostTagGet
//
//	SELECT
//	    post_id, tag_id
//	FROM
//	    post_tags
//	WHERE
//	    post_id = ?
//	    AND tag_id = ?
func (q *Queries) PostTagGet(ctx context.Context, postID int64, tagID int64) (PostTag, error) {
	row := q.db.QueryRowContext(ctx, postTagGet, postID, tagID)
	var i PostTag
	err := row.Scan(&i.PostID, &i.TagID)
	return i, err
}

const postTagsGetByPostID = `-- name: PostTagsGetByPostID :many
SELECT
    post_id, tag_id
FROM
    post_tags
WHERE
    post_id = ?
`

// PostTagsGetByPostID
//
//	SELECT
//	    post_id, tag_id
//	FROM
//	    post_tags
//	WHERE
//	    post_id = ?
func (q *Queries) PostTagsGetByPostID(ctx context.Context, postID int64) ([]PostTag, error) {
	rows, err := q.db.QueryContext(ctx, postTagsGetByPostID, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostTag
	for rows.Next() {
		var i PostTag
		if err := rows.Scan(&i.PostID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postTagsGetByTagID = `-- name: PostTagsGetByTagID :many
SELECT
    post_id, tag_id
FROM
    post_tags
WHERE
    tag_id = ?
`

// PostTagsGetByTagID
//
//	SELECT
//	    post_id, tag_id
//	FROM
//	    post_tags
//	WHERE
//	    tag_id = ?
func (q *Queries) PostTagsGetByTagID(ctx context.Context, tagID int64) ([]PostTag, error) {
	rows, err := q.db.QueryContext(ctx, postTagsGetByTagID, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostTag
	for rows.Next() {
		var i PostTag
		if err := rows.Scan(&i.PostID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postUpdate = `-- name: PostUpdate :one
UPDATE
    posts
SET
    title = ?,
    description = ?,
    slug = ?,
    content = ?,
    raw_content = ?,
    banner_url = ?,
    embedding_id = ?
WHERE
    id = ? RETURNING id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
`

type PostUpdateParams struct {
	Title       string `db:"title" json:"title"`
	Description string `db:"description" json:"description"`
	Slug        string `db:"slug" json:"slug"`
	Content     string `db:"content" json:"content"`
	RawContent  string `db:"raw_content" json:"raw_content"`
	BannerUrl   string `db:"banner_url" json:"banner_url"`
	EmbeddingID int64  `db:"embedding_id" json:"embedding_id"`
	ID          int64  `db:"id" json:"id"`
}

// PostUpdate
//
//	UPDATE
//	    posts
//	SET
//	    title = ?,
//	    description = ?,
//	    slug = ?,
//	    content = ?,
//	    raw_content = ?,
//	    banner_url = ?,
//	    embedding_id = ?
//	WHERE
//	    id = ? RETURNING id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
func (q *Queries) PostUpdate(ctx context.Context, arg PostUpdateParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, postUpdate,
		arg.Title,
		arg.Description,
		arg.Slug,
		arg.Content,
		arg.RawContent,
		arg.BannerUrl,
		arg.EmbeddingID,
		arg.ID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Content,
		&i.RawContent,
		&i.BannerUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmbeddingID,
	)
	return i, err
}

const postsList = `-- name: PostsList :many
SELECT
    id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
FROM
    posts
ORDER BY
    created_at DESC
`

// PostsList
//
//	SELECT
//	    id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
//	FROM
//	    posts
//	ORDER BY
//	    created_at DESC
func (q *Queries) PostsList(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, postsList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Content,
			&i.RawContent,
			&i.BannerUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmbeddingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postsListByProject = `-- name: PostsListByProject :many
SELECT
    p.id, p.title, p.slug, p.description, p.content, p.raw_content, p.banner_url, p.created_at, p.updated_at, p.embedding_id
FROM
    posts p
    JOIN post_projects pp ON p.id = pp.post_id
WHERE
    pp.project_id = ?
ORDER BY
    p.created_at DESC
`

// PostsListByProject
//
//	SELECT
//	    p.id, p.title, p.slug, p.description, p.content, p.raw_content, p.banner_url, p.created_at, p.updated_at, p.embedding_id
//	FROM
//	    posts p
//	    JOIN post_projects pp ON p.id = pp.post_id
//	WHERE
//	    pp.project_id = ?
//	ORDER BY
//	    p.created_at DESC
func (q *Queries) PostsListByProject(ctx context.Context, projectID int64) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, postsListByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Content,
			&i.RawContent,
			&i.BannerUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmbeddingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postsListByTag = `-- name: PostsListByTag :many
SELECT
    p.id, p.title, p.slug, p.description, p.content, p.raw_content, p.banner_url, p.created_at, p.updated_at, p.embedding_id
FROM
    posts p
    JOIN post_tags pt ON p.id = pt.post_id
WHERE
    pt.tag_id = ?
ORDER BY
    p.created_at DESC
`

// PostsListByTag
//
//	SELECT
//	    p.id, p.title, p.slug, p.description, p.content, p.raw_content, p.banner_url, p.created_at, p.updated_at, p.embedding_id
//	FROM
//	    posts p
//	    JOIN post_tags pt ON p.id = pt.post_id
//	WHERE
//	    pt.tag_id = ?
//	ORDER BY
//	    p.created_at DESC
func (q *Queries) PostsListByTag(ctx context.Context, tagID int64) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, postsListByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Content,
			&i.RawContent,
			&i.BannerUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmbeddingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectCreate = `-- name: ProjectCreate :one
INSERT INTO
    projects (
        title,
        slug,
        description,
        content,
        raw_content,
        banner_url,
        embedding_id
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?) RETURNING id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
`

type ProjectCreateParams struct {
	Title       string `db:"title" json:"title"`
	Slug        string `db:"slug" json:"slug"`
	Description string `db:"description" json:"description"`
	Content     string `db:"content" json:"content"`
	RawContent  string `db:"raw_content" json:"raw_content"`
	BannerUrl   string `db:"banner_url" json:"banner_url"`
	EmbeddingID int64  `db:"embedding_id" json:"embedding_id"`
}

// ProjectCreate
//
//	INSERT INTO
//	    projects (
//	        title,
//	        slug,
//	        description,
//	        content,
//	        raw_content,
//	        banner_url,
//	        embedding_id
//	    )
//	VALUES
//	    (?, ?, ?, ?, ?, ?, ?) RETURNING id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
func (q *Queries) ProjectCreate(ctx context.Context, arg ProjectCreateParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, projectCreate,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.Content,
		arg.RawContent,
		arg.BannerUrl,
		arg.EmbeddingID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Content,
		&i.RawContent,
		&i.BannerUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmbeddingID,
	)
	return i, err
}

const projectGetByID = `-- name: ProjectGetByID :one
SELECT
    id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
FROM
    projects
WHERE
    id = ?
LIMIT
    1
`

// ProjectGetByID
//
//	SELECT
//	    id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
//	FROM
//	    projects
//	WHERE
//	    id = ?
//	LIMIT
//	    1
func (q *Queries) ProjectGetByID(ctx context.Context, id int64) (Project, error) {
	row := q.db.QueryRowContext(ctx, projectGetByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Content,
		&i.RawContent,
		&i.BannerUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmbeddingID,
	)
	return i, err
}

const projectGetBySlug = `-- name: ProjectGetBySlug :one
SELECT
    id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
FROM
    projects
WHERE
    slug = ?
LIMIT
    1
`

// ProjectGetBySlug
//
//	SELECT
//	    id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
//	FROM
//	    projects
//	WHERE
//	    slug = ?
//	LIMIT
//	    1
func (q *Queries) ProjectGetBySlug(ctx context.Context, slug string) (Project, error) {
	row := q.db.QueryRowContext(ctx, projectGetBySlug, slug)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Content,
		&i.RawContent,
		&i.BannerUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmbeddingID,
	)
	return i, err
}

const projectTagCreate = `-- name: ProjectTagCreate :exec
INSERT INTO
    project_tags (project_id, tag_id)
VALUES
    (?, ?)
`

// ProjectTagCreate
//
//	INSERT INTO
//	    project_tags (project_id, tag_id)
//	VALUES
//	    (?, ?)
func (q *Queries) ProjectTagCreate(ctx context.Context, projectID int64, tagID int64) error {
	_, err := q.db.ExecContext(ctx, projectTagCreate, projectID, tagID)
	return err
}

const projectTagDelete = `-- name: ProjectTagDelete :exec
DELETE FROM
    project_tags
WHERE
    project_id = ?
    AND tag_id = ?
`

// ProjectTagDelete
//
//	DELETE FROM
//	    project_tags
//	WHERE
//	    project_id = ?
//	    AND tag_id = ?
func (q *Queries) ProjectTagDelete(ctx context.Context, projectID int64, tagID int64) error {
	_, err := q.db.ExecContext(ctx, projectTagDelete, projectID, tagID)
	return err
}

const projectTagsGet = `-- name: ProjectTagsGet :many
SELECT
    project_id, tag_id
FROM
    project_tags
WHERE
    project_id = ?
    AND tag_id = ?
`

// ProjectTagsGet
//
//	SELECT
//	    project_id, tag_id
//	FROM
//	    project_tags
//	WHERE
//	    project_id = ?
//	    AND tag_id = ?
func (q *Queries) ProjectTagsGet(ctx context.Context, projectID int64, tagID int64) ([]ProjectTag, error) {
	rows, err := q.db.QueryContext(ctx, projectTagsGet, projectID, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectTag
	for rows.Next() {
		var i ProjectTag
		if err := rows.Scan(&i.ProjectID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectTagsGetByProjectID = `-- name: ProjectTagsGetByProjectID :many
SELECT
    project_id, tag_id
FROM
    project_tags
WHERE
    project_id = ?
`

// ProjectTagsGetByProjectID
//
//	SELECT
//	    project_id, tag_id
//	FROM
//	    project_tags
//	WHERE
//	    project_id = ?
func (q *Queries) ProjectTagsGetByProjectID(ctx context.Context, projectID int64) ([]ProjectTag, error) {
	rows, err := q.db.QueryContext(ctx, projectTagsGetByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectTag
	for rows.Next() {
		var i ProjectTag
		if err := rows.Scan(&i.ProjectID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectUpdate = `-- name: ProjectUpdate :one
UPDATE
    projects
SET
    title = ?,
    slug = ?,
    description = ?,
    content = ?,
    raw_content = ?,
    banner_url = ?,
    embedding_id = ?
WHERE
    id = ? RETURNING id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
`

type ProjectUpdateParams struct {
	Title       string `db:"title" json:"title"`
	Slug        string `db:"slug" json:"slug"`
	Description string `db:"description" json:"description"`
	Content     string `db:"content" json:"content"`
	RawContent  string `db:"raw_content" json:"raw_content"`
	BannerUrl   string `db:"banner_url" json:"banner_url"`
	EmbeddingID int64  `db:"embedding_id" json:"embedding_id"`
	ID          int64  `db:"id" json:"id"`
}

// ProjectUpdate
//
//	UPDATE
//	    projects
//	SET
//	    title = ?,
//	    slug = ?,
//	    description = ?,
//	    content = ?,
//	    raw_content = ?,
//	    banner_url = ?,
//	    embedding_id = ?
//	WHERE
//	    id = ? RETURNING id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
func (q *Queries) ProjectUpdate(ctx context.Context, arg ProjectUpdateParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, projectUpdate,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.Content,
		arg.RawContent,
		arg.BannerUrl,
		arg.EmbeddingID,
		arg.ID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Content,
		&i.RawContent,
		&i.BannerUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmbeddingID,
	)
	return i, err
}

const projectsList = `-- name: ProjectsList :many
SELECT
    id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
FROM
    projects
ORDER BY
    created_at DESC
`

// ProjectsList
//
//	SELECT
//	    id, title, slug, description, content, raw_content, banner_url, created_at, updated_at, embedding_id
//	FROM
//	    projects
//	ORDER BY
//	    created_at DESC
func (q *Queries) ProjectsList(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, projectsList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Content,
			&i.RawContent,
			&i.BannerUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmbeddingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectsListByPost = `-- name: ProjectsListByPost :many
SELECT
    p.id, p.title, p.slug, p.description, p.content, p.raw_content, p.banner_url, p.created_at, p.updated_at, p.embedding_id
FROM
    projects p
    JOIN post_projects pp ON p.id = pp.project_id
WHERE
    pp.post_id = ?
ORDER BY
    p.created_at DESC
`

// ProjectsListByPost
//
//	SELECT
//	    p.id, p.title, p.slug, p.description, p.content, p.raw_content, p.banner_url, p.created_at, p.updated_at, p.embedding_id
//	FROM
//	    projects p
//	    JOIN post_projects pp ON p.id = pp.project_id
//	WHERE
//	    pp.post_id = ?
//	ORDER BY
//	    p.created_at DESC
func (q *Queries) ProjectsListByPost(ctx context.Context, postID int64) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, projectsListByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Content,
			&i.RawContent,
			&i.BannerUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmbeddingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectsListByTag = `-- name: ProjectsListByTag :many
SELECT
    p.id, p.title, p.slug, p.description, p.content, p.raw_content, p.banner_url, p.created_at, p.updated_at, p.embedding_id
FROM
    projects p
    JOIN project_tags pt ON p.id = pt.project_id
WHERE
    pt.tag_id = ?
ORDER BY
    p.created_at DESC
`

// ProjectsListByTag
//
//	SELECT
//	    p.id, p.title, p.slug, p.description, p.content, p.raw_content, p.banner_url, p.created_at, p.updated_at, p.embedding_id
//	FROM
//	    projects p
//	    JOIN project_tags pt ON p.id = pt.project_id
//	WHERE
//	    pt.tag_id = ?
//	ORDER BY
//	    p.created_at DESC
func (q *Queries) ProjectsListByTag(ctx context.Context, tagID int64) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, projectsListByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Content,
			&i.RawContent,
			&i.BannerUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmbeddingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagCreate = `-- name: TagCreate :exec
INSERT INTO
    tags (title, content, raw_content, slug, embedding_id)
VALUES
    (?, ?, ?, ?, ?)
`

type TagCreateParams struct {
	Title       string `db:"title" json:"title"`
	Content     string `db:"content" json:"content"`
	RawContent  string `db:"raw_content" json:"raw_content"`
	Slug        string `db:"slug" json:"slug"`
	EmbeddingID int64  `db:"embedding_id" json:"embedding_id"`
}

// TagCreate
//
//	INSERT INTO
//	    tags (title, content, raw_content, slug, embedding_id)
//	VALUES
//	    (?, ?, ?, ?, ?)
func (q *Queries) TagCreate(ctx context.Context, arg TagCreateParams) error {
	_, err := q.db.ExecContext(ctx, tagCreate,
		arg.Title,
		arg.Content,
		arg.RawContent,
		arg.Slug,
		arg.EmbeddingID,
	)
	return err
}

const tagGetByID = `-- name: TagGetByID :one
SELECT
    id, title, slug, content, raw_content, icon, created_at, updated_at, embedding_id
FROM
    tags
WHERE
    id = ?
LIMIT
    1
`

// TagGetByID
//
//	SELECT
//	    id, title, slug, content, raw_content, icon, created_at, updated_at, embedding_id
//	FROM
//	    tags
//	WHERE
//	    id = ?
//	LIMIT
//	    1
func (q *Queries) TagGetByID(ctx context.Context, id int64) (Tag, error) {
	row := q.db.QueryRowContext(ctx, tagGetByID, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.RawContent,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmbeddingID,
	)
	return i, err
}

const tagGetBySlug = `-- name: TagGetBySlug :one
SELECT
    id, title, slug, content, raw_content, icon, created_at, updated_at, embedding_id
FROM
    tags
WHERE
    slug = ?
LIMIT
    1
`

// TagGetBySlug
//
//	SELECT
//	    id, title, slug, content, raw_content, icon, created_at, updated_at, embedding_id
//	FROM
//	    tags
//	WHERE
//	    slug = ?
//	LIMIT
//	    1
func (q *Queries) TagGetBySlug(ctx context.Context, slug string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, tagGetBySlug, slug)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.RawContent,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmbeddingID,
	)
	return i, err
}

const tagUpdate = `-- name: TagUpdate :exec
UPDATE
    tags
SET
    title = ?,
    slug = ?,
    content = ?,
    raw_content = ?,
    embedding_id = ?
WHERE
    id = ?
`

type TagUpdateParams struct {
	Title       string `db:"title" json:"title"`
	Slug        string `db:"slug" json:"slug"`
	Content     string `db:"content" json:"content"`
	RawContent  string `db:"raw_content" json:"raw_content"`
	EmbeddingID int64  `db:"embedding_id" json:"embedding_id"`
	ID          int64  `db:"id" json:"id"`
}

// TagUpdate
//
//	UPDATE
//	    tags
//	SET
//	    title = ?,
//	    slug = ?,
//	    content = ?,
//	    raw_content = ?,
//	    embedding_id = ?
//	WHERE
//	    id = ?
func (q *Queries) TagUpdate(ctx context.Context, arg TagUpdateParams) error {
	_, err := q.db.ExecContext(ctx, tagUpdate,
		arg.Title,
		arg.Slug,
		arg.Content,
		arg.RawContent,
		arg.EmbeddingID,
		arg.ID,
	)
	return err
}

const tagsListAlphabetical = `-- name: TagsListAlphabetical :many
SELECT
    t.id, t.title, t.slug, t.content, t.raw_content, t.icon, t.created_at, t.updated_at, t.embedding_id
FROM
    tags t
ORDER BY
    t.title ASC
`

// TagsListAlphabetical
//
//	SELECT
//	    t.id, t.title, t.slug, t.content, t.raw_content, t.icon, t.created_at, t.updated_at, t.embedding_id
//	FROM
//	    tags t
//	ORDER BY
//	    t.title ASC
func (q *Queries) TagsListAlphabetical(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, tagsListAlphabetical)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.RawContent,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmbeddingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagsListByPost = `-- name: TagsListByPost :many
SELECT
    t.id, t.title, t.slug, t.content, t.raw_content, t.icon, t.created_at, t.updated_at, t.embedding_id
FROM
    tags t
    JOIN post_tags pt ON t.id = pt.tag_id
WHERE
    pt.post_id = ?
ORDER BY
    t.title ASC
`

// TagsListByPost
//
//	SELECT
//	    t.id, t.title, t.slug, t.content, t.raw_content, t.icon, t.created_at, t.updated_at, t.embedding_id
//	FROM
//	    tags t
//	    JOIN post_tags pt ON t.id = pt.tag_id
//	WHERE
//	    pt.post_id = ?
//	ORDER BY
//	    t.title ASC
func (q *Queries) TagsListByPost(ctx context.Context, postID int64) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, tagsListByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.RawContent,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmbeddingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagsListByProject = `-- name: TagsListByProject :many
SELECT
    t.id, t.title, t.slug, t.content, t.raw_content, t.icon, t.created_at, t.updated_at, t.embedding_id
FROM
    tags t
    JOIN project_tags pt ON t.id = pt.tag_id
WHERE
    pt.project_id = ?
ORDER BY
    t.title ASC
`

// TagsListByProject
//
//	SELECT
//	    t.id, t.title, t.slug, t.content, t.raw_content, t.icon, t.created_at, t.updated_at, t.embedding_id
//	FROM
//	    tags t
//	    JOIN project_tags pt ON t.id = pt.tag_id
//	WHERE
//	    pt.project_id = ?
//	ORDER BY
//	    t.title ASC
func (q *Queries) TagsListByProject(ctx context.Context, projectID int64) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, tagsListByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.RawContent,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmbeddingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
