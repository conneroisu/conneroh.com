package views

import (
	"fmt"
	"github.com/conneroisu/conneroh.com/internal/data/master"
	"time"
)

templ Posts(posts *[]master.FullPost) {
	<script type="module">
// This code will implement posts filtering by +tag and -tag
// Function to parse URL query params and extract tag filters
function parseTagFilters(queryString) {
  const params = new URLSearchParams(queryString);
  const tags = params.get('tags') || '';
  
  const includeTags = [];
  const excludeTags = [];
  
  // Parse the tags parameter for +tag and -tag patterns
  const tagPatterns = tags.split(/\s+/).filter(tag => tag.trim().length > 0);
  
  tagPatterns.forEach(pattern => {
    if (pattern.startsWith('+')) {
      const tag = pattern.substring(1).trim();
      if (tag) includeTags.push(tag);
    } else if (pattern.startsWith('-')) {
      const tag = pattern.substring(1).trim();
      if (tag) excludeTags.push(tag);
    } else {
      // If no prefix, assume include
      if (pattern.trim()) includeTags.push(pattern.trim());
    }
  });
  
  return { includeTags, excludeTags };
}

// Function to filter posts based on tags
function filterPostsByTags(posts, includeTags, excludeTags) {
  if (includeTags.length === 0 && excludeTags.length === 0) {
    return posts; // No filtering needed
  }
  
  return posts.filter(post => {
    const postTags = post.tags.map(tag => tag.name.toLowerCase());
    
    // Check if post should be excluded
    if (excludeTags.length > 0) {
      const shouldExclude = excludeTags.some(tag => 
        postTags.includes(tag.toLowerCase())
      );
      if (shouldExclude) return false;
    }
    
    // Check if post should be included
    if (includeTags.length > 0) {
      const shouldInclude = includeTags.every(tag => 
        postTags.includes(tag.toLowerCase())
      );
      return shouldInclude;
    }
    
    // If we have excludes but no includes, keep all posts that weren't excluded
    return true;
  });
}

// Function to generate tag filter UI
function generateTagFilterUI(allTags, currentIncludeTags, currentExcludeTags) {
  let html = '<div class="tag-filter-container">';
  html += '<h3>Filter by Tags</h3>';
  
  // Show current filters
  if (currentIncludeTags.length > 0 || currentExcludeTags.length > 0) {
    html += '<div class="current-filters">';
    html += '<span>Current filters: </span>';
    
    currentIncludeTags.forEach(tag => {
      html += `<span class="filter-tag include">+${tag} <a href="#" class="remove-filter" data-tag="${tag}" data-action="remove-include">×</a></span>`;
    });
    
    currentExcludeTags.forEach(tag => {
      html += `<span class="filter-tag exclude">-${tag} <a href="#" class="remove-filter" data-tag="${tag}" data-action="remove-exclude">×</a></span>`;
    });
    
    html += '<a href="?tags=" class="clear-filters">Clear all filters</a>';
    html += '</div>';
  }
  
  // Available tags to filter by
  html += '<div class="available-tags">';
  allTags.forEach(tag => {
    const isIncluded = currentIncludeTags.includes(tag.toLowerCase());
    const isExcluded = currentExcludeTags.includes(tag.toLowerCase());
    
    if (!isIncluded && !isExcluded) {
      html += `<span class="tag">
        ${tag}
        <a href="?tags=${encodeURIComponent(currentTagsParam(currentIncludeTags, currentExcludeTags) + ' +' + tag)}" class="include-tag">+</a>
        <a href="?tags=${encodeURIComponent(currentTagsParam(currentIncludeTags, currentExcludeTags) + ' -' + tag)}" class="exclude-tag">-</a>
      </span>`;
    }
  });
  html += '</div>';
  
  html += '</div>';
  return html;
}

// Helper to reconstruct current tags parameter
function currentTagsParam(includeTags, excludeTags) {
  let tagsParam = '';
  
  includeTags.forEach(tag => {
    tagsParam += ' +' + tag;
  });
  
  excludeTags.forEach(tag => {
    tagsParam += ' -' + tag;
  });
  
  return tagsParam.trim();
}

// Main code to integrate with the posts view
document.addEventListener('alpine:init', () => {
  Alpine.data('postFilters', () => ({
    queryString: window.location.search,
    allTags: [],
    includeTags: [],
    excludeTags: [],
    
    init() {
      // Extract all unique tags from posts
      this.allTags = [...new Set(
        Array.from(document.querySelectorAll('[data-post-tags]'))
          .map(el => JSON.parse(el.getAttribute('data-post-tags') || '[]'))
          .flat()
          .map(tag => tag.name)
      )];
      
      // Parse current filters
      const { includeTags, excludeTags } = parseTagFilters(this.queryString);
      this.includeTags = includeTags;
      this.excludeTags = excludeTags;
      
      // Apply filters to Alpine.js data
      this.$watch('filteredPosts', (posts) => {
        const filtered = filterPostsByTags(posts, this.includeTags, this.excludeTags);
        return filtered;
      });
    },
    
    toggleIncludeTag(tag) {
      if (this.includeTags.includes(tag)) {
        this.includeTags = this.includeTags.filter(t => t !== tag);
      } else {
        this.includeTags.push(tag);
        // Remove from exclude if it's there
        this.excludeTags = this.excludeTags.filter(t => t !== tag);
      }
      this.updateURL();
    },
    
    toggleExcludeTag(tag) {
      if (this.excludeTags.includes(tag)) {
        this.excludeTags = this.excludeTags.filter(t => t !== tag);
      } else {
        this.excludeTags.push(tag);
        // Remove from include if it's there
        this.includeTags = this.includeTags.filter(t => t !== tag);
      }
      this.updateURL();
    },
    
    updateURL() {
      let tagsParam = currentTagsParam(this.includeTags, this.excludeTags);
      
      // Update the URL
      const url = new URL(window.location);
      if (tagsParam) {
        url.searchParams.set('tags', tagsParam);
      } else {
        url.searchParams.delete('tags');
      }
      
      window.history.pushState({}, '', url);
    }
  }));
});
</script>
	<div
		class="container mx-auto px-4 py-8"
		x-data="{
		posts: [],
		searchQuery: '',
		selectedTag: '',
		tags: [],
		init() {
			// Initialize posts from the rendered template data
			this.posts = Array.from(document.querySelectorAll('[data-post-id]')).map(post => {
				return {
					id: post.getAttribute('data-post-id'),
					title: post.getAttribute('data-post-title'),
					description: post.getAttribute('data-post-description'),
					slug: post.getAttribute('data-post-slug'),
					date: post.getAttribute('data-post-date'),
					banner: post.getAttribute('data-post-banner'),
					tags: JSON.parse(post.getAttribute('data-post-tags') || '[]')
				};
			});
			
			// Extract all unique tags
			const allTags = new Set();
			this.posts.forEach(post => {
				post.tags.forEach(tag => allTags.add(tag.name));
			});
			this.tags = Array.from(allTags);
		},
		filteredPosts() {
			return this.posts.filter(post => {
				const matchesSearch = this.searchQuery === '' || 
					post.title.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
					post.description.toLowerCase().includes(this.searchQuery.toLowerCase());
				
				const matchesTag = this.selectedTag === '' ||
					post.tags.some(tag => tag.name === this.selectedTag);
				
				return matchesSearch && matchesTag;
			});
		}
	}"
	>
		<h1 class="text-3xl font-bold mb-6 text-gray-900 dark:text-white">Blog Posts</h1>
		<!-- Search and Filter Controls -->
		<div class="flex flex-col md:flex-row justify-between mb-8 gap-4">
			<div class="relative w-full md:w-1/2">
				<input
					type="text"
					x-model="searchQuery"
					placeholder="Search posts..."
					class="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-white"
				/>
				<div class="absolute right-3 top-2.5 text-gray-400">
					<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
					</svg>
				</div>
			</div>
			<div class="w-full md:w-1/3">
				<select
					x-model="selectedTag"
					class="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-white"
				>
					<option value="">All Tags</option>
					<template x-for="tag in tags" :key="tag">
						<option x-text="tag" :value="tag"></option>
					</template>
				</select>
			</div>
		</div>
		<!-- Results info -->
		<p class="text-sm text-gray-500 dark:text-gray-400 mb-4" x-text="`Showing ${filteredPosts().length} of ${posts.length} posts`"></p>
		<!-- Posts Grid -->
		<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
			<!-- Hidden data elements for Alpine to process -->
			if posts != nil {
				for _, post := range *posts {
					// Format tags data for JSON storage
					<div
						class="hidden"
						data-post-id={ fmt.Sprintf("%d", post.ID) }
						data-post-title={ post.Title }
						data-post-description={ post.Description }
						data-post-slug={ post.Slug }
						data-post-date={ formatDate(post.CreatedAt) }
						data-post-banner={ post.BannerUrl }
						data-post-tags={ formatTags(post.Tags) }
					></div>
				}
			}
			<!-- Template for displaying posts -->
			<template x-for="post in filteredPosts()" :key="post.id">
				<div class="bg-white dark:bg-gray-800 rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow duration-300">
					<a :href="`/post/${post.slug}`" class="block">
						<img :src="post.banner || '/dist/placeholder.jpg'" :alt="post.title" class="w-full h-48 object-cover object-center"/>
						<div class="p-6">
							<div class="flex justify-between items-start mb-2">
								<h2 class="text-xl font-semibold text-gray-900 dark:text-white" x-text="post.title"></h2>
								<span class="text-sm text-gray-500 dark:text-gray-400" x-text="post.date"></span>
							</div>
							<p class="text-gray-600 dark:text-gray-300 mb-4 line-clamp-3" x-text="post.description"></p>
							<div class="flex flex-wrap gap-2">
								<template x-for="tag in post.tags" :key="tag.id">
									<span
										class="inline-block px-2 py-1 text-xs font-medium rounded-full bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200"
										x-text="tag.name"
										@click.stop="selectedTag = tag.name"
									></span>
								</template>
							</div>
						</div>
					</a>
				</div>
			</template>
			<!-- Empty state -->
			<div
				class="col-span-full py-12 text-center text-gray-500 dark:text-gray-400"
				x-show="filteredPosts().length === 0"
			>
				<svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
				</svg>
				<p class="text-lg">No posts match your search</p>
				<button
					@click="searchQuery = ''; selectedTag = '';"
					class="mt-4 px-4 py-2 text-sm font-medium text-blue-600 dark:text-blue-400 hover:underline"
				>
					Clear filters
				</button>
			</div>
		</div>
	</div>
}

// Helper functions for formatting data for Alpine.js
func formatDate(timestamp int64) string {
	t := time.Unix(timestamp, 0)
	return t.Format("Jan 02, 2006")
}

func formatTags(tags []master.Tag) string {
	// This is a simplified representation - in a real app, you might want to use a JSON library
	if len(tags) == 0 {
		return "[]"
	}

	result := "["
	for i, tag := range tags {
		if i > 0 {
			result += ","
		}
		result += fmt.Sprintf(`{"id":%d,"name":"%s","slug":"%s"}`, tag.ID, tag.Name, tag.Slug)
	}
	result += "]"
	return result
}

// Individual Post component
templ Post(post *master.FullPost) {
	<article class="container mx-auto px-4 py-8 max-w-3xl">
		<div class="mb-8">
			<h1 class="text-4xl font-bold text-gray-900 dark:text-white mb-4">{ post.Title }</h1>
			<div class="flex items-center text-gray-500 dark:text-gray-400 mb-6">
				<time datetime={ time.Unix(post.CreatedAt, 0).Format("2006-01-02") }>
					{ formatDate(post.CreatedAt) }
				</time>
				<span class="mx-2">•</span>
				<span>{ readTime(post.Content) } min read</span>
			</div>
			<div class="flex flex-wrap gap-2 mb-8">
				for _, tag := range post.Tags {
					<a
						href={ templ.SafeURL(fmt.Sprintf("/tag/%s", tag.Slug)) }
						class="inline-block px-3 py-1 text-sm font-medium rounded-full bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200 hover:bg-blue-200 dark:hover:bg-blue-800 transition-colors"
					>
						{ tag.Name }
					</a>
				}
			</div>
			if post.BannerUrl != "" {
				<img
					src={ post.BannerUrl }
					alt={ post.Title }
					class="w-full h-64 md:h-96 object-cover object-center rounded-lg shadow-md mb-8"
				/>
			}
		</div>
		<div class="prose prose-lg dark:prose-invert max-w-none">
			@templ.Raw(post.Content)
		</div>
		if len(post.Projects) > 0 {
			<div class="mt-12 border-t border-gray-200 dark:border-gray-700 pt-8">
				<h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-4">Related Projects</h2>
				<div class="grid grid-cols-1 md:grid-cols-2 gap-4">
					for _, project := range post.Projects {
						<a
							href={ templ.SafeURL(fmt.Sprintf("/project/%s", project.Slug)) }
							class="flex items-center p-4 bg-gray-50 dark:bg-gray-800 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
						>
							<div>
								<h3 class="font-medium text-gray-900 dark:text-white">{ project.Name }</h3>
								<p class="text-gray-500 dark:text-gray-400 text-sm line-clamp-2">{ project.Description }</p>
							</div>
						</a>
					}
				</div>
			</div>
		}
	</article>
}

func readTime(content string) string {
	// Rough estimate - 200 words per minute reading speed
	words := len(content) / 5 // Average word length is 5 characters
	minutes := words / 200

	if minutes < 1 {
		return "1"
	}
	return fmt.Sprintf("%d", minutes)
}
